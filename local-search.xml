<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>函数式编程中的 fix</title>
    <link href="/2022/05/19/fix-in-functional-programming/"/>
    <url>/2022/05/19/fix-in-functional-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="先看看-fix-是什么"><a class="markdownIt-Anchor" href="#先看看-fix-是什么"></a> 先看看 fix 是什么</h1><p>这是 <code>fix</code> 在 Haskell 中的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fix</span> :: (a -&gt; a) -&gt; a<br><span class="hljs-title">fix</span> f = <span class="hljs-keyword">let</span> x = f x <span class="hljs-keyword">in</span> x<br></code></pre></td></tr></table></figure><p>哇！好怪，这个 <code>x</code> 是什么？我们好像只能知道它满足 <code>x = f x</code>，但是这个值具体是怎么求的呢？</p><h1 id="那我们还是先看看-fix-的应用吧"><a class="markdownIt-Anchor" href="#那我们还是先看看-fix-的应用吧"></a> 那我们还是先看看 <code>fix</code> 的应用吧</h1><p>通常我们会这样定义阶乘。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fact</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">fact</span> <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-title">fact</span> n = n * fact (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>如果转换成 lambda 表达式呢？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fact</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">fact</span> = \n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <br>             <span class="hljs-keyword">then</span> <span class="hljs-number">1</span><br>             <span class="hljs-keyword">else</span> n * _ (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这个 <code>_</code> 应该填什么？对照上文的代码，我们应该要填入一个 <code>fact</code>。但是在这个 lambda 表达式中，<code>fact</code> 还没有被定义…</p><p>那我们可以试着多传一个参数作为参数穿进去。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fact</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">fact</span> f = \n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><br>               <span class="hljs-keyword">then</span> <span class="hljs-number">1</span><br>               <span class="hljs-keyword">else</span> n * f (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>也就是说，我们需要向 <code>fact</code> 提供一个真正的阶乘函数来得到一个阶乘函数。按照这样的想法，我们可以写出这样的代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">realFact</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> <br><span class="hljs-title">realFact</span> = fact realFact<br></code></pre></td></tr></table></figure><p>咦 <code>x = f x</code>，这不就是上面的 <code>fix</code> 吗？于是我们可以把 <code>fact</code> 定义成这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fact</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">fact</span> = fix $ \f n -&gt;<br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <br>  <span class="hljs-keyword">then</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span> n * f (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>唔 那再给出几个常见的递归函数的 <code>fix</code> 实现以供参考。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fib</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">fib</span> = fix $ \f n -&gt;<br>  <span class="hljs-keyword">case</span> n <span class="hljs-keyword">of</span><br>  <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span> -&gt; <span class="hljs-number">1</span><br>  n&#x27; -&gt; f (n&#x27; - <span class="hljs-number">1</span>) + f (n&#x27; - <span class="hljs-number">2</span>)<br><br><span class="hljs-title">eq</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">eq</span> = fix $ \f n m -&gt;<br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><br>  <span class="hljs-keyword">then</span> m == <span class="hljs-number">0</span><br>  <span class="hljs-keyword">else</span> f (n - <span class="hljs-number">1</span>) (m - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="那-fix-是怎么计算的呢"><a class="markdownIt-Anchor" href="#那-fix-是怎么计算的呢"></a> 那 <code>fix</code> 是怎么计算的呢</h1><p>参考 SF-PLF-MoreStcl 一节中对 <code>fix</code> 的形式化定义，可以写出两条规约公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>t</mi><mo>→</mo><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup></mrow><mrow><mtext>fix </mtext><mi>t</mi><mo>→</mo><mtext>fix </mtext><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{t \rarr t&#x27;}{\text{fix } t \rarr \text{fix } t&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.114892em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.428892em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">fix </span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">fix </span></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow></mrow><mrow><mtext>fix </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">[</mo><mi>f</mi><mo>:</mo><mo>=</mo><mtext>fix </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mtext> </mtext><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{}{\text{fix } (\lambda f.t)\rarr [f:=\text{fix } (\lambda f.t)]\,t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.613em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">fix </span></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">fix </span></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>那么，我们试着依照这个规则来计算 <code>fact 2</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fact</span> <span class="hljs-number">2</span><br>=&gt; fix (\f n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n * f (n - <span class="hljs-number">1</span>)) <span class="hljs-number">2</span><br>=&gt; (\n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n * fact (n - <span class="hljs-number">1</span>)) <span class="hljs-number">2</span><br>=&gt; <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> * fact (<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)<br>=&gt; <span class="hljs-number">2</span> * fact <span class="hljs-number">1</span><br>=&gt; <span class="hljs-number">2</span> * (fix (\f n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n * f (n - <span class="hljs-number">1</span>))) <span class="hljs-number">1</span><br>=&gt; <span class="hljs-number">2</span> * (\n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n * fact (n - <span class="hljs-number">1</span>)) <span class="hljs-number">1</span><br>=&gt; <span class="hljs-number">2</span> * (<span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> * fact (<span class="hljs-number">1</span> - <span class="hljs-number">1</span>))<br>=&gt; <span class="hljs-number">2</span> * <span class="hljs-number">1</span> * fact <span class="hljs-number">0</span><br>=&gt; <span class="hljs-number">2</span> * <span class="hljs-number">1</span> * (fix (\f n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n * f (n - <span class="hljs-number">1</span>))) <span class="hljs-number">0</span><br>=&gt; <span class="hljs-number">2</span> * <span class="hljs-number">1</span> * (\n -&gt; <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n * fact (n - <span class="hljs-number">1</span>)) <span class="hljs-number">0</span><br>=&gt; <span class="hljs-number">2</span> * <span class="hljs-number">1</span> * (<span class="hljs-keyword">if</span> <span class="hljs-number">0</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> * fact (<span class="hljs-number">0</span> - <span class="hljs-number">1</span>))<br>=&gt; <span class="hljs-number">2</span> * <span class="hljs-number">1</span> * <span class="hljs-number">1</span><br>=&gt; <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="从不动点的角度理解-fix"><a class="markdownIt-Anchor" href="#从不动点的角度理解-fix"></a> 从不动点的角度理解 <code>fix</code></h1><p>回到 <code>x = f x</code>，我们可以发现 <code>x</code> 就是 <code>f</code> 的一个不动点。</p><p>也就是说，对于某些点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_n = f(x_{n-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">n\rarr +\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_n = f(x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>而对于 <code>fact</code>，先令 <code>ft = \f n -&gt; if n == 0 then 1 else n * f (n - 1)</code>。</p><p>如果我们令 <code>x0 = id</code>：</p><p><code>ft id</code> 可以正确计算所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p><code>ft $ ft id</code> 可以正确计算所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p><code>ft $ ft $ ft id</code> 可以正确计算所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n \leq 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p><p>…</p><p>最终，我们有 <code>fact = ft fact</code>，也就是说 <code>fact</code> 是 <code>ft</code> 的一个不动点。对 <code>id</code> 反复迭代 <code>ft</code> 就能逐渐逼近 <code>fact</code>。（实际上 <code>id</code> 可以换成任意一个类型为 <code>Int -&gt; Int</code> 的函数）</p><h1 id="一点闲谈"><a class="markdownIt-Anchor" href="#一点闲谈"></a> 一点闲谈</h1><ol><li>coq 中定义递归函数的关键字就是 <code>Fixpoint</code>。</li><li>在 lambda 演算中，<code>fix</code> 还有一个名字叫 Y-combiner。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>fp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
